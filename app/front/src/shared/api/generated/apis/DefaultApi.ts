// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * Toxicity Gateway
 * FastAPI эндпоинт, который проксирует запросы к Triton и возвращает флаг токсичности.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateDialogRequest,
  DialogOut,
  DialogWithMessagesOut,
  HTTPValidationError,
  LoginRequest,
  LoginResponse,
  MessageView,
  SendMessageRequest,
  UserOut,
} from '../models/index';
import {
    CreateDialogRequestFromJSON,
    CreateDialogRequestToJSON,
    DialogOutFromJSON,
    DialogOutToJSON,
    DialogWithMessagesOutFromJSON,
    DialogWithMessagesOutToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    LoginResponseFromJSON,
    LoginResponseToJSON,
    MessageViewFromJSON,
    MessageViewToJSON,
    SendMessageRequestFromJSON,
    SendMessageRequestToJSON,
    UserOutFromJSON,
    UserOutToJSON,
} from '../models/index';

export interface AdminDialogByIdAdminDialogsDialogIdGetRequest {
    dialogId: number;
}

export interface CreateDialogEndpointUserDialogsPostRequest {
    createDialogRequest: CreateDialogRequest;
}

export interface LoginLoginPostRequest {
    loginRequest: LoginRequest;
}

export interface SendMessageEndpointMessagesPostRequest {
    sendMessageRequest: SendMessageRequest;
}

export interface ToxicityPipelineGetRequest {
    text: string;
}

export interface UserDialogMessagesUserDialogsDialogIdGetRequest {
    dialogId: number;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Диалог по id (админ): сообщения (старые→новые) с именем отправителя
     */
    async adminDialogByIdAdminDialogsDialogIdGetRaw(requestParameters: AdminDialogByIdAdminDialogsDialogIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DialogWithMessagesOut>> {
        if (requestParameters['dialogId'] == null) {
            throw new runtime.RequiredError(
                'dialogId',
                'Required parameter "dialogId" was null or undefined when calling adminDialogByIdAdminDialogsDialogIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/admin/dialogs/{dialog_id}`.replace(`{${"dialog_id"}}`, encodeURIComponent(String(requestParameters['dialogId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DialogWithMessagesOutFromJSON(jsonValue));
    }

    /**
     * Диалог по id (админ): сообщения (старые→новые) с именем отправителя
     */
    async adminDialogByIdAdminDialogsDialogIdGet(requestParameters: AdminDialogByIdAdminDialogsDialogIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DialogWithMessagesOut> {
        const response = await this.adminDialogByIdAdminDialogsDialogIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Все переписки (админ): id + category + сообщения (старые→новые) с именем отправителя
     */
    async adminListDialogsWithMessagesAdminDialogsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DialogWithMessagesOut>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/admin/dialogs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DialogWithMessagesOutFromJSON));
    }

    /**
     * Все переписки (админ): id + category + сообщения (старые→новые) с именем отправителя
     */
    async adminListDialogsWithMessagesAdminDialogsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DialogWithMessagesOut>> {
        const response = await this.adminListDialogsWithMessagesAdminDialogsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Статистика по БД (админ)
     */
    async adminStatsAdminStatsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/admin/stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Статистика по БД (админ)
     */
    async adminStatsAdminStatsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.adminStatsAdminStatsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Создать новое обращение (диалог) для пользователя
     */
    async createDialogEndpointUserDialogsPostRaw(requestParameters: CreateDialogEndpointUserDialogsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DialogOut>> {
        if (requestParameters['createDialogRequest'] == null) {
            throw new runtime.RequiredError(
                'createDialogRequest',
                'Required parameter "createDialogRequest" was null or undefined when calling createDialogEndpointUserDialogsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/dialogs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateDialogRequestToJSON(requestParameters['createDialogRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DialogOutFromJSON(jsonValue));
    }

    /**
     * Создать новое обращение (диалог) для пользователя
     */
    async createDialogEndpointUserDialogsPost(requestParameters: CreateDialogEndpointUserDialogsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DialogOut> {
        const response = await this.createDialogEndpointUserDialogsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Информация о текущем пользователе
     */
    async getMeMeGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserOut>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/me`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserOutFromJSON(jsonValue));
    }

    /**
     * Информация о текущем пользователе
     */
    async getMeMeGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserOut> {
        const response = await this.getMeMeGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Health
     */
    async healthHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Health
     */
    async healthHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.healthHealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Логин по email и паролю
     */
    async loginLoginPostRaw(requestParameters: LoginLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LoginResponse>> {
        if (requestParameters['loginRequest'] == null) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter "loginRequest" was null or undefined when calling loginLoginPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LoginRequestToJSON(requestParameters['loginRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LoginResponseFromJSON(jsonValue));
    }

    /**
     * Логин по email и паролю
     */
    async loginLoginPost(requestParameters: LoginLoginPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LoginResponse> {
        const response = await this.loginLoginPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Отправить сообщение в диалог (возвращает MessageView)
     */
    async sendMessageEndpointMessagesPostRaw(requestParameters: SendMessageEndpointMessagesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageView>> {
        if (requestParameters['sendMessageRequest'] == null) {
            throw new runtime.RequiredError(
                'sendMessageRequest',
                'Required parameter "sendMessageRequest" was null or undefined when calling sendMessageEndpointMessagesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/messages`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SendMessageRequestToJSON(requestParameters['sendMessageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageViewFromJSON(jsonValue));
    }

    /**
     * Отправить сообщение в диалог (возвращает MessageView)
     */
    async sendMessageEndpointMessagesPost(requestParameters: SendMessageEndpointMessagesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageView> {
        const response = await this.sendMessageEndpointMessagesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Toxicity
     */
    async toxicityPipelineGetRaw(requestParameters: ToxicityPipelineGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling toxicityPipelineGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['text'] != null) {
            queryParameters['text'] = requestParameters['text'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/pipeline`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Toxicity
     */
    async toxicityPipelineGet(requestParameters: ToxicityPipelineGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.toxicityPipelineGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Сообщения диалога (старые→новые) с именем отправителя
     */
    async userDialogMessagesUserDialogsDialogIdGetRaw(requestParameters: UserDialogMessagesUserDialogsDialogIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DialogWithMessagesOut>> {
        if (requestParameters['dialogId'] == null) {
            throw new runtime.RequiredError(
                'dialogId',
                'Required parameter "dialogId" was null or undefined when calling userDialogMessagesUserDialogsDialogIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/dialogs/{dialog_id}`.replace(`{${"dialog_id"}}`, encodeURIComponent(String(requestParameters['dialogId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DialogWithMessagesOutFromJSON(jsonValue));
    }

    /**
     * Сообщения диалога (старые→новые) с именем отправителя
     */
    async userDialogMessagesUserDialogsDialogIdGet(requestParameters: UserDialogMessagesUserDialogsDialogIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DialogWithMessagesOut> {
        const response = await this.userDialogMessagesUserDialogsDialogIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Диалоги текущего пользователя: id + сообщения (старые→новые, с именем отправителя)
     */
    async userDialogsWithMessagesUserDialogsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DialogWithMessagesOut>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user/dialogs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DialogWithMessagesOutFromJSON));
    }

    /**
     * Диалоги текущего пользователя: id + сообщения (старые→новые, с именем отправителя)
     */
    async userDialogsWithMessagesUserDialogsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DialogWithMessagesOut>> {
        const response = await this.userDialogsWithMessagesUserDialogsGetRaw(initOverrides);
        return await response.value();
    }

}
